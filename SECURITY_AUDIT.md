# Аудит информационной безопасности — AI Chat

**Дата:** 13.02.2025  
**Объект:** монорепозиторий ai-chat (бэкенд NestJS, фронтенд Next.js).

---

## Резюме

| Категория        | Критично | Высокий | Средний | Низкий |
|------------------|----------|---------|---------|--------|
| Количество       | 4        | 4       | 5       | 2      |

Рекомендуется в первую очередь устранить критические и высокие риски, затем — средние.

---

## 1. Критические находки

### 1.1 Незащищённый endpoint `POST /api/chat`

- **Файл:** `ai-chat-backend/src/chat/chat.controller.ts`
- **Проблема:** Эндпоинт не использует `UseGuards`; любой может отправлять запросы к OpenRouter за счёт вашего API-ключа (расход средств, DoS).
- **Рекомендация:** Удалить эндпоинт (фронтенд использует `POST /api/conversations/:id/messages`) или защитить его `JwtAuthGuard` и лимитами.

### 1.2 Загрузка изображений без авторизации и лимитов

- **Файл:** `ai-chat-backend/src/upload/upload.controller.ts`
- **Проблема:** `POST /api/upload-images` доступен без авторизации; нет ограничения на размер тела и количество/размер base64-изображений → риск DoS и заполнения диска.
- **Рекомендация:** Требовать авторизацию (например, `OptionalJwtGuard` или `JwtAuthGuard`), ограничить размер тела запроса (NestJS/Express `limit`), лимит на количество изображений и размер каждого (например, макс. 5 МБ на запрос).

### 1.3 Fallback JWT_SECRET в production

- **Файлы:** `ai-chat-backend/src/auth/jwt.strategy.ts`, `ai-chat-backend/src/auth/auth.module.ts`
- **Проблема:** При отсутствии `JWT_SECRET` используется строка `'dev-secret-change-in-production'`. В production это позволяет подделывать JWT.
- **Рекомендация:** В среде `production` не использовать fallback; при отсутствии `JWT_SECRET` падать при старте приложения.

### 1.4 XSS при отображении Markdown

- **Файл:** `ai-chat-frontend/src/shared/ui/markdown/Markdown.tsx`
- **Проблема:** Результат `marked.parse()` вставляется через `dangerouslySetInnerHTML` без санитизации. В markdown можно внедрить HTML/JS (например, `<img onerror="...">`), что ведёт к XSS.
- **Рекомендация:** Санитизировать HTML через DOMPurify после парсинга markdown (или использовать marked с опцией санитизации, если доступна).

---

## 2. Высокий приоритет

### 2.1 ADMIN_SECRET в теле запроса

- **Файл:** `ai-chat-backend/src/users/users.controller.ts`
- **Проблема:** Секрет передаётся в `body.adminSecret` и может попадать в логи прокси/сервера. Предпочтительно передавать секреты в заголовке.
- **Рекомендация:** Принимать админ-ключ из заголовка (например, `X-Admin-Key` или `Authorization: Bearer <ADMIN_SECRET>`) и не использовать тело для секрета.

### 2.2 Отсутствие rate limiting

- **Проблема:** Нет ограничения частоты запросов к `/api/auth/login`, `/api/auth/register`, `/api/admin/top-up` и к API чата → перебор паролей, спам регистраций, злоупотребление админ-эндпоинтом.
- **Рекомендация:** Подключить `@nestjs/throttler` (или аналог) и задать лимиты для auth, admin и chat-эндпоинтов.

### 2.3 Логирование содержимого сообщений

- **Файл:** `ai-chat-backend/src/conversations/conversations.service.ts` — `writeLog(\`Use ${model} to generate response: ${messageText}\`)`
- **Проблема:** В `usage.log` попадает полный текст сообщения пользователя (PII, персональные данные), что нежелательно с точки зрения GDPR/законодательства и утечек.
- **Рекомендация:** Не логировать тело сообщения или логировать только хеш/длину/модель и стоимость.

### 2.4 Диалоги без привязки к пользователю

- **Файлы:** `conversations.controller.ts`, `conversations.service.ts`
- **Проблема:** `GET /api/conversations`, `POST /api/conversations`, `GET /api/conversations/:id` не требуют авторизации; диалоги хранятся в памяти и не привязаны к пользователю. Идентификаторы предсказуемы/перебираемы.
- **Рекомендация:** Либо привязать диалоги к пользователю и защитить эндпоинты JWT, либо явно документировать, что диалоги публичные/временные и не содержат PII.

---

## 3. Средний приоритет

### 3.1 Валидация пароля только на фронтенде

- **Файл:** `ai-chat-backend/src/auth/auth.controller.ts`, `users.service.ts`
- **Проблема:** Минимальная длина пароля (например, 6) проверяется только в форме (frontend). Прямые запросы к API могут создавать пользователей с очень коротким паролем.
- **Рекомендация:** На бэкенде проверять длину (например, ≥ 8) и при необходимости сложность пароля (например, через class-validator).

### 3.2 Нет заголовков безопасности (Helmet)

- **Файл:** `ai-chat-backend/src/main.ts`
- **Проблема:** Не устанавливаются заголовки вроде `X-Content-Type-Options`, `X-Frame-Options`, `Content-Security-Policy` и т.д.
- **Рекомендация:** Подключить `helmet` (или `@nestjs/platform-express` + helmet) и настроить под приложение.

### 3.3 Валидация формата email

- **Файл:** `ai-chat-backend/src/auth/auth.controller.ts`
- **Проблема:** Проверяется только наличие строки; формат email не валидируется.
- **Рекомендация:** Использовать class-validator (`IsEmail`) или регулярное выражение для формата email.

### 3.4 Блог: вывод HTML без санитизации

- **Файл:** `ai-chat-backend/src/blog/blog.service.ts`
- **Проблема:** Контент из локальных `.md` файлов рендерится через `marked.parse()` и отдаётся как HTML. Если файлы блога когда-либо будут редактироваться извне или из ненадёжного источника — возможен XSS.
- **Рекомендация:** Санитизировать HTML перед отдачей (например, DOMPurify на бэкенде или при генерации).

### 3.5 Отсутствие .env.example в репозитории

- **Проблема:** В git status указано удаление `ai-chat-backend/.env.example`. Новым разработчикам и деплою сложнее понять обязательные переменные.
- **Рекомендация:** Вернуть `.env.example` с перечислением переменных без реальных значений (и добавить в .gitignore только `.env`, не `.env.example`).

---

## 4. Низкий приоритет

### 4.1 Зависимости бэкенда (npm audit)

- **Проблема:** `npm audit` сообщает об уязвимостях в dev-зависимостях (glob, tmp, webpack, inquirer и др. через @nestjs/cli). В рантайме приложения они не используются, но обновление снижает риски при сборке.
- **Рекомендация:** Периодически обновлять зависимости; при необходимости — `npm audit fix` (с учётом возможных breaking changes).

### 4.2 Служебная cookie сессии на фронтенде

- **Файл:** `ai-chat-frontend/src/features/auth/context/AuthProvider.tsx`
- **Проблема:** Cookie `ai_chat_session` выставляется без `HttpOnly` (доступна из JS). Она используется только как подсказка «есть ли сессия» и не хранит секретов, но увеличивает поверхность атаки.
- **Рекомендация:** Оставить как есть или заменить на проверку через один запрос к `/api/auth/me` без отдельной cookie.

---

## 5. Что сделано хорошо

- Пароли хранятся в виде bcrypt-хеша; `passwordHash` исключён из выборки по умолчанию в entity.
- JWT передаётся в httpOnly cookie и поддерживается Bearer в заголовке; в production включён `secure` для cookie.
- CORS настроен по whitelist (`CORS_ORIGIN`), `credentials: true` для cookie.
- Модели чата проверяются по белому списку (`ALLOWED_MODEL_IDS`), нет прямой подстановки в запрос к OpenRouter.
- В блоге используется `path.basename` и замена недопустимых символов в slug — снижен риск path traversal.
- Фронтенд использует `credentials: 'include'` для запросов к API, что корректно для cookie-based auth.

---

## 6. Выполненные доработки (первая итерация)

- **POST /api/chat** — добавлен `@UseGuards(JwtAuthGuard)`; для вызова требуется авторизация.
- **POST /api/upload-images** — добавлен `@UseGuards(JwtAuthGuard)`, лимит 10 изображений и 3 МБ на файл; в `main.ts` установлен лимит тела запроса 20 МБ.
- **JWT_SECRET** — в production при отсутствии переменной приложение выбрасывает ошибку при старте (auth.module.ts, jwt.strategy.ts).
- **Markdown XSS** — вывод обрабатывается через `isomorphic-dompurify` после `marked.parse()` (Markdown.tsx).
- **ADMIN_SECRET** — поддерживается передача в заголовке `X-Admin-Key` (body по-прежнему допускается для совместимости).
- **Логирование** — полный текст сообщения пользователя больше не пишется в usage.log; сохраняются только модель и стоимость.
- **.env.example** — восстановлен в ai-chat-backend с перечнем переменных без секретов.

Рекомендуется дополнительно внедрить rate limiting (Throttler) и Helmet — см. ниже.

## 7. Проверка после доработок

После внесения исправлений рекомендуется:

1. Убедиться, что `POST /api/chat` либо удалён, либо защищён и не доступен анонимно.
2. Проверить, что `POST /api/upload-images` требует авторизацию и отклоняет слишком большие запросы.
3. В production при отсутствии `JWT_SECRET` приложение не стартует.
4. В Markdown-компоненте вывод проходит через DOMPurify (или аналог).
5. Админ-действия используют заголовок для секрета, а не тело.
6. На критичных маршрутах включён rate limiting.
7. В логах не сохраняется полный текст сообщений пользователей.
8. Запустить `npm run build` и тесты (если есть) после изменений.

**Примечание:** Загрузка изображений (`POST /api/upload-images`) после доработок доступна только авторизованным пользователям. Гости могут пользоваться бесплатными моделями без прикрепления изображений.

---

## 8. Вторая итерация доработок (rate limiting, Helmet, валидация, диалоги для гостей)

### 8.1 Rate limiting (@nestjs/throttler)

- **Глобально:** `ThrottlerGuard` подключён как `APP_GUARD`; лимит по умолчанию 200 запросов в минуту на IP.
- **Auth (login/register):** `@Throttle({ default: { limit: 5, ttl: 60_000 } })` — 5 попыток в минуту с одного IP (защита от перебора паролей и спама регистраций).
- **Admin (top-up):** `@Throttle({ default: { limit: 10, ttl: 60_000 } })` — 10 запросов в минуту.
- **Отправка сообщений в диалог:** `@Throttle({ default: { limit: 40, ttl: 60_000 } })` на `POST /api/conversations/:id/messages` — 40 сообщений в минуту с одного IP (гости и пользователи), защита от злоупотребления бесплатными моделями.

### 8.2 Helmet

- В `main.ts` подключён `helmet()` с опцией `crossOriginResourcePolicy: { policy: 'cross-origin' }` (чтобы загрузки/статику по CORS не блокировало). Остальные заголовки (X-Content-Type-Options, X-Frame-Options и т.д.) выставляются по умолчанию.

### 8.3 Валидация пароля и email

- **DTO:** Введены `LoginDto` и `RegisterDto` (class-validator).
- **Email:** `@IsEmail()` — проверка формата на бэкенде.
- **Пароль:** `@MinLength(8)` для входа и регистрации, `@MaxLength(128)` для регистрации.
- Включён глобальный `ValidationPipe` с `whitelist: true`, `transform: true`.
- На фронтенде в форме авторизации минимальная длина пароля приведена к 8 символам и отображается подсказка.

### 8.4 Диалоги: отправка сообщений неавторизованными пользователями

- **Текущая реализация сохранена и явно зафиксирована:** эндпоинт `POST /api/conversations/:id/messages` защищён только `OptionalJwtGuard` — JWT не обязателен. Если пользователь не авторизован, `req.user` будет `undefined`.
- **Логика в контроллере:** для **бесплатных** моделей (`isModelFree(model) === true`) запрос выполняется без проверки пользователя и баланса. Для **платных** моделей возвращается `401` с кодом `AUTH_REQUIRED`, если пользователь не авторизован, и `403` с кодом `INSUFFICIENT_BALANCE`, если баланса недостаточно.
- **Итог:** гости могут без входа создавать диалоги (`POST /api/conversations`), получать список и диалог по id (`GET /api/conversations`, `GET /api/conversations/:id`) и **отправлять сообщения только в бесплатные модели** через `POST /api/conversations/:id/messages`. Платные модели и загрузка изображений по-прежнему требуют авторизации. Ограничение по злоупотреблению — rate limit 40 сообщений в минуту с одного IP.
